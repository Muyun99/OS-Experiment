<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A">操作系统实验报告</h1>
<h1 id="1-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE">1. 文件读写编程题目</h1>
<h3 id="11-myechoc">1.1 myecho.c</h3>
<ul>
<li>myecho.c 的功能与系统 echo 程序相同</li>
<li>接受命令行参数，并将参数打印出来，例子如下：</li>
</ul>
<pre class="hljs"><code><div>$ ./myecho x
x
$ ./myecho a b c
a b c
</div></code></pre>
<h4 id="111-myecho-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">1.1.1 myecho 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int i = 0;
    for(i = 1; i &lt; argc; i++)
        printf(&quot;%s &quot;,argv[i]);
    printf(&quot;\n&quot;);
    return 0;
}
</div></code></pre>
<h4 id="112-myecho-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">1.1.2 myecho 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/25/5d1230a55ff6e.png" alt="myecho.png"></p>
<h4 id="113-myecho-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">1.1.3 myecho 实验思路</h4>
<p>1.实验预备知识</p>
<p>(1) main 函数的参数有 argc 和 argv 两个参数</p>
<p>(2) int argc(arguments count)<br>
argc 表示运行程序传送给 main 函数的命令行参数总个数，包括可执行程序名，其中当 argc=1 时表示只有一个程序名称，此时存储在 argv[0]中</p>
<p>(3) char *argv[](arguments value/vecotr)<br>
argv 是一个字符串数组，用来存放指向字符串参数的指针数组，每个元素只想一个参数，空格分割参数，其长度为 argc。数组下标从 0 开始，argv[argc] = NULL。</p>
<p>2.实验思路
使用 main 函数的 argv 与 argc 传递参数，命令行输入的字符串会被分割为字符串数组。用 argc 作为循环变量，输出 argv 字符串数组中的值，注意用空格分隔即可。需要注意的是：argv[0]中存储的是程序名称，这里不应该被输出，所以下标应从 1 开始。</p>
<h3 id="12-mycatc">1.2 mycat.c</h3>
<ul>
<li>mycat.c 的功能与系统 cat 程序相同</li>
<li>mycat 将指定的文件内容输出到屏幕，例子如下：</li>
<li>要求使用系统调用 open/read/write/close 实现</li>
</ul>
<pre class="hljs"><code><div>$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
$ ./mycat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
</div></code></pre>
<h4 id="121-mycat-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">1.2.1 mycat 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;

int main(int argc, char *argv[])
{
	int fd;
	char c[1];
    if(argc == 1)
	{
		while(read(0,c,1))
			write(1,c,1);
	}
	else
	{
		int i = 0;
		for(i = 1;i &lt; argc;i++)
		{
		    fd = open(argv[i], O_RDONLY);
			if(fd == -1)    //file open error，output error message
			{
				printf(&quot;mycat: %s:No such file or directory\n&quot;, argv[i]);
				continue;
			}
			while(read(fd,c,1))
				write(1,c,1);
			close(fd);
		}
    }
    return 0;
}

</div></code></pre>
<h4 id="122-mycat-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">1.2.2 mycat 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/25/5d123f0e6bd4f.png" alt="mycat.png"></p>
<h4 id="123-mycat-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">1.2.3 mycat 实验思路</h4>
<p>1.cat 命令后可不接参数</p>
<p>基于此想法，当命令后参数数量为 0(即 argc 为 1 时)，我们将接收到的字符串进行原样不动的输出。</p>
<p>read(0,c,1)表示从标准输入中读取字符数组</p>
<p>write(1,c,1)表示将读取的字符数组写到标准输出中去</p>
<p>2.cat 命令后可接多个参数</p>
<p>基于此想法，当命令后参数数量不为 0 是(即 argc&gt;1 时)，我们对 argv 中的文件名进行逐个访问并打开，最后调用 read 与 write 函数将当前文件的字符写到标准输出中去。值得注意的是，如果文件夹名字不合法(即 open 函数返回为-1)，则应输出报错信息。</p>
<h3 id="13-mycpc">1.3 mycp.c</h3>
<ul>
<li>mycp.c 的功能与系统 cp 程序相同</li>
<li>将源文件复制到目标文件，例子如下：</li>
<li>要求使用系统调用 open/read/write/close 实现</li>
</ul>
<pre class="hljs"><code><div>$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
$ ./mycp /etc/passwd passwd.bak
$ cat passwd.bak
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
</div></code></pre>
<h4 id="131-mycp-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">1.3.1 mycp 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    if(argc != 3)
	{
		printf(&quot;please check your format, the right format:cp file_src file_target\n&quot;);
		exit(0);
	}

    char *sourcePath = argv[1];
    char *targetPath = argv[2];

    int fd1 = open(sourcePath, O_RDONLY);
    int fd2 = open(targetPath, O_WRONLY | O_CREAT | O_TRUNC, 0644);

	if(fd1 == -1)
	{
		printf(&quot;open %s error!&quot;,sourcePath);
		exit(0);
	}
	if(fd2 == -1)
	{
		printf(&quot;open %s error!&quot;,targetPath);
		exit(0);
	}
    char buf[1];
    int count;

    while (read(fd1, buf,1))
    {
        write(fd2, buf, 1);
    }
    close(fd1);
    close(fd2);
    return 0;
}

</div></code></pre>
<h4 id="132-mycp-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">1.3.2 mycp 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d12482f41037.png" alt="mycp.png"></p>
<h4 id="133-mycp-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">1.3.3 mycp 实验思路</h4>
<p>1.首先对命令格式与文件是否正常打开进行判断</p>
<p>当命令后跟的参数数量少于 3 个时候，提醒用户输入格式错误，并退出当前程序。当文件打开错误时，也提醒用户打开文件失败，并退出当前程序。这里需要注意的点是，在打开目标文件时，若目标文件不存在应该创建一个新文件(O_CREAT)，并且为了能够后续操作，将其权限赋为默认权限：664 权限。</p>
<p>2.进行复制</p>
<p>当文件都正常打开时，按照以往的方法进行复制。调用 read 函数对源文件逐个读取，当其返回的字符个数为 1 时，调用 write 函数写入目标文件中。</p>
<h1 id="2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%A2%98%E7%9B%AE">2. 多进程题目</h1>
<h3 id="21-mysysc-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0-mysys%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%A6%81%E6%B1%82%E5%A6%82%E4%B8%8B">2.1 mysys.c: 实现函数 mysys，用于执行一个系统命令，要求如下</h3>
<ul>
<li>mysys 的功能与系统函数 system 相同，要求用进程管理相关系统调用自己实现一遍</li>
<li>使用 fork/exec/wait 系统调用实现 mysys</li>
<li>不能通过调用系统函数 system 实现 mysys</li>
<li>测试程序</li>
</ul>
<pre class="hljs"><code><div>#include &lt;stdio.h&gt;

void mysys(char *command)
{
    实现该函数，该函数执行一条命令，并等待该命令执行结束
}

int main()
{
    printf(&quot;--------------------------------------------------\n&quot;);
    mysys(&quot;echo HELLO WORLD&quot;);
    printf(&quot;--------------------------------------------------\n&quot;);
    mysys(&quot;ls /&quot;);
    printf(&quot;--------------------------------------------------\n&quot;);
    return 0;
}
</div></code></pre>
<ul>
<li>测试程序的输出结果</li>
</ul>
<pre class="hljs"><code><div>--------------------------------------------------
HELLO WORLD
--------------------------------------------------
bin    core  home	     lib	 mnt   root  snap  tmp	vmlinuz
boot   dev   initrd.img      lost+found  opt   run   srv   usr	vmlinuz.old
cdrom  etc   initrd.img.old  media	 proc  sbin  sys   var
--------------------------------------------------
</div></code></pre>
<h4 id="211-mysys-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">2.1.1 mysys 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/types.h&gt;

int mysys(char *command)
{
	if(command[0] == '\0')
	{
		printf(&quot;command not found!\n&quot;);
		return 127; // &quot;command not found!&quot;
	}
    int pid;
    pid = fork();
    if(pid == 0)
    {
        char *argv[100];
        char *token;
        char cmd[sizeof(command) + 1];
        strcpy(cmd, command);

		//get first substr
        token = strtok(cmd, &quot; &quot;);
        int count = 0;
        while(token != NULL)
        {
            argv[count++] = token;
            token = strtok(NULL,&quot; &quot;);
        }
        argv[count] = 0;
        if(execvp(argv[0],argv) == -1)
            printf(&quot;exec failed: %d\n&quot;,errno);
    }
    else
        wait(NULL);
}

int main()
{
	mysys(&quot;&quot;);
    printf(&quot;-------------------------------------------\n&quot;);
	mysys(&quot;pwd&quot;);

	printf(&quot;-------------------------------------------\n&quot;);
	mysys(&quot;ls&quot;);

    printf(&quot;-------------------------------------------\n&quot;);
    mysys(&quot;echo HELLO WORLD&quot;);

    printf(&quot;-------------------------------------------\n&quot;);
    mysys(&quot;ls /&quot;);

    printf(&quot;-------------------------------------------\n&quot;);
    return 0;
}
</div></code></pre>
<h4 id="212-mysys-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">2.1.2 mysys 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d12546b0072e.png" alt="mysys.png"></p>
<h4 id="213-mysys-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">2.1.3 mysys 实验思路</h4>
<p>1.先验知识</p>
<p>(1) execvp 函数</p>
<p>int execvp(const char _file, char _ const argv []);</p>
<p>execvp()会从 PATH 环境变量所指的目录中查找符合参数 file 的文件名, 找到后便执行该文件, 然后将第二个参数 argv 传给该欲执行的文件</p>
<p>(2) strtok 函数</p>
<p>char *strtok(char *str, const char *delim)</p>
<p>str -- 要被分解成一组小字符串的字符串</p>
<p>delim -- 包含分隔符的 C 字符串。</p>
<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>
<p>(3) fork 函数</p>
<p>pid_t fork(void);</p>
<p>pid 是进程 ID 的缩写，pid_t 是使用 typedef 定义的进程 ID 类型</p>
<p>父进程从 fork 返回处继续执行，在父进程中，fork 返回子进程 PID</p>
<p>子进程从 fork 返回处开始执行，在子进程中，fork 返回 0</p>
<p>2.实验思路</p>
<p>(1) 首先判断命令是否合法，经过对传入的命令字符数组的首个字符串进行判断，若不存在则打印错误信息并 return 127(返回 127 是指 command not found!)</p>
<p>(2) 然后进行 fork 产生子进程，在子进程中完成对 execvp 函数的调用，其中若(pid==0)表达式为真，即当前进程为子进程。</p>
<p>(3) 在子进程中对传入的字符串进行分割，这里用到了 strtok 函数对空格进行分割，将其分割后的子字符串存入 argv 字符数组中，然后调用 execvp 函数，传入命令及 argv 字符串进行系统调用。</p>
<p>(4) 父进程中等待子进程完成后退出 mysys 函数。</p>
<h3 id="22-sh1c">2.2 sh1.c</h3>
<ul>
<li>该程序读取用户输入的命令，调用函数 mysys(上一个作业)执行用户的命令，示例如下</li>
</ul>
<pre class="hljs"><code><div># 编译sh1.c
$ cc -o sh1 sh1.c

# 执行sh1
$ ./sh

# sh1打印提示符&gt;，同时读取用户输入的命令echo，并执行输出结果
&gt; echo a b c
a b c

# sh1打印提示符&gt;，同时读取用户输入的命令cat，并执行输出结果
&gt; cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
</div></code></pre>
<ul>
<li>请考虑如何实现内置命令 cd、pwd、exit</li>
</ul>
<h4 id="221-sh1-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">2.2.1 sh1 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;errno.h&gt;
#include&lt;string.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/types.h&gt;
char *home;
char *dir;
int mysys(char *command)
{
	if(command[0] == '\0')
	{
		printf(&quot;command not found!\n&quot;);
		return 127; //&quot;command not found!&quot;
	}
    int pid;
    pid = fork();
    if(pid == 0)
    {
        char *argv[100];
        char *token;
        char cmd[sizeof(command) + 1];
        strcpy(cmd, command);

		//get first substr
        token = strtok(cmd, &quot; &quot;);
        int count = 0;
        while(token != NULL)
        {
            argv[count++] = token;
            token = strtok(NULL,&quot; &quot;);
        }
        argv[count] = 0;
	    if(execvp(argv[0],argv) == -1)
            printf(&quot;exec failed: %d\n&quot;,errno);
    }
    else
        wait(NULL);

}

int choose_fun(char *cmd)
{
	char argv[100];
	strcpy(argv,cmd);

	if(argv[0] == '\0')
		return 0;
	char *token = strtok(argv, &quot; &quot;);

	if(strcmp(token,&quot;cd&quot;) == 0)
		return 1;
	else if(strcmp(token,&quot;exit&quot;) == 0)
		return 2;
	else
		return 0;
}

int main()
{
	home = getenv(&quot;HOME&quot;);
	char buff[100];
	while(1)
	{
		dir = getcwd(NULL,0);
		printf(&quot;[%s]&gt; &quot;,dir);
		gets(buff);

		int cmdStatus = choose_fun(buff);

		if(cmdStatus == 0)
			mysys(buff);
		else if(cmdStatus == 1)
		{
			char targetdir[256];
			sscanf(buff,&quot;cd %s&quot;,targetdir);
			chdir(targetdir);
		}
		else if(cmdStatus == 2)
			exit(0);
	}
}

</div></code></pre>
<h4 id="222-sh1-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">2.2.2 sh1 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d12fb7ab037c.png" alt="sh1.png">
<img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d12fbdb5e288.png" alt="sh1-2.png"></p>
<p>如上图所示，我实现了 ls 等基础命令的同时，也实现了 cd、pwd、exit 等内置命令。</p>
<h4 id="223-sh1-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">2.2.3 sh1 实验思路</h4>
<p>1.先验知识</p>
<p>sscanf()</p>
<p>函数原型：int sscanf(const char _<strong>restrict</strong> _Src, const char _<strong>restrict</strong> _Format, ...)</p>
<p>函数功能：从一个字符串中读进与指定格式相符的数据的函数。sscanf 与 scanf 类似，都是用于输入的，只是后者以屏幕(stdin)为输入源，前者以固定字符串为输入源。</p>
<p>函数示例：sscanf(buff,&quot;cd %s&quot;,targetdir);</p>
<p>2.实验思路</p>
<p>(1) 先判断其是否为内置指令 cd 以及 exit。调用 strtok 函数获得指令的一个命令字，若是 cd 命令则返回 1，若是 exit 指令则返回 2，若都不是则返回 3</p>
<pre class="hljs"><code><div>int choose_fun(char *cmd)
{
	char argv[100];
	strcpy(argv,cmd);

	if(argv[0] == '\0')
		return 0;
	char *token = strtok(argv, &quot; &quot;);

	if(strcmp(token,&quot;cd&quot;) == 0)
		return 1;
	else if(strcmp(token,&quot;exit&quot;) == 0)
		return 2;
	else
		return 0;
}
</div></code></pre>
<p>(2) main 函数中对 choose_fun 返回的状态进行判断，若是普通指令则调用 mysys 函数执行，若是 cd 指令调用 sscanf 指令对指令字符串进行解析得到 targetdir 然后改变路径至 targetdir</p>
<pre class="hljs"><code><div>int main()
{
	home = getenv(&quot;HOME&quot;);
	char buff[100];
	while(1)
	{
		dir = getcwd(NULL,0);
		printf(&quot;[%s]&gt; &quot;,dir);
		gets(buff);

		int cmdStatus = choose_fun(buff);

		if(cmdStatus == 0)
			mysys(buff);
		else if(cmdStatus == 1)
		{
			char targetdir[256];
			sscanf(buff,&quot;cd %s&quot;,targetdir);
			chdir(targetdir);
		}
		else if(cmdStatus == 2)
			exit(0);
	}
}
</div></code></pre>
<h3 id="23-sh2c-%E5%AE%9E%E7%8E%B0-shell-%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%A6%81%E6%B1%82%E5%9C%A8%E7%AC%AC-1-%E7%89%88%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E5%8A%9F%E8%83%BD">2.3 sh2.c: 实现 shell 程序，要求在第 1 版的基础上，添加如下功能</h3>
<ul>
<li>实现文件重定向</li>
</ul>
<pre class="hljs"><code><div># 执行sh2
$ ./sh2

# 执行命令echo，并将输出保存到文件log中
&gt; echo hello &gt;log

# 打印cat命令的输出结果
&gt; cat log
hello
</div></code></pre>
<h4 id="231-sh2-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">2.3.1 sh2 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;errno.h&gt;
#include&lt;string.h&gt;
#include&lt;unistd.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
char *home;
char *dir;
int std_in;
int std_out;
int mysys(char *command)
{
	int status = -1;
	if(command[0] == '\0')
	{
		printf(&quot;command not found!\n&quot;);
		return 127; //&quot;command not found!&quot;
	}
    pid_t pid;
    pid = fork();
    if(pid == 0)
    {
        char *argv[100];
        char *token;
        char cmd[sizeof(command) + 1];
        strcpy(cmd, command);
    
		//get first substr
        token = strtok(cmd, &quot; &quot;);
        int count = 0;
        while(token != NULL)
        {
            argv[count++] = token;
            token = strtok(NULL,&quot; &quot;); 
        }
        argv[count] = 0;
	    if(execvp(argv[0],argv)==-1)
		{
			printf(&quot;exec failed: &quot;);
			printf(&quot;%d\n&quot;,errno);
		}
		else
			status = 1;
    }
    else
        while(waitpid(pid,NULL,0) &lt; 0)
		{
			if(errno!=EINTR)
				status = -1;
				break;	
		}
	
	dup2(std_in,0);
	dup2(std_out,1);
	return status;
}
int choose_fun(char *cmd)
{
	char argv[100];
	strcpy(argv,cmd);

	if(argv[0] == '\0')
		return 0;
	char *token = strtok(argv, &quot; &quot;);

	if(strcmp(token,&quot;cd&quot;) == 0)
		return 1;
	else if(strcmp(token,&quot;exit&quot;) == 0)
		return 2;
	else
		return 0;
}

int loop()
{
	printf(&quot;debug1&quot;);
	char buff[100];
	char tempstr[100];
	home = getenv(&quot;HOME&quot;);
	dir = getcwd(NULL,0);
	printf(&quot;[%s]&gt; &quot;,dir);
	gets(buff);

	char *a = NULL;
	char *b = NULL;
	a = strchr(buff, '&lt;');
	b = strchr(buff, '&gt;');
	
	int inindex = 0;
	int outindex = 0;
	int count = 0;

	char *argv[100];
	char *token;
	char cmd[sizeof(buff) + 1];
	strcpy(cmd, buff);
	token = strtok(cmd,&quot;&quot;);
	while(token != NULL)
	{
		if(strchr(token,'&lt;'))
			inindex = count+1;
		else if(strchr(token,'&gt;'))
			outindex = count+1;
		argv[count++] = token;
		token = strtok(cmd,&quot; &quot;);
	}

	if(a != NULL &amp;&amp; b != NULL)
	{
		char *in = argv[inindex];
		char *out = argv[outindex];
		int fdin,fdout;
		fdin = open(in,O_RDWR,0666);
		fdout = open(out,O_CREAT|O_RDWR,0666);
		if(fdin == -1)
		{
			printf(&quot;File %s open failed!\n&quot;,in);
			return -1;
		}
		if(fdout == -1)
		{
			printf(&quot;File %s open failed!\n&quot;,out);
			return -1;
		}
		dup2(fdin,0);
		dup2(fdout,1);
		close(fdin);
		close(fdout);
		return mysys(buff);
	}
	else if(a != NULL)
	{
		char *in = argv[inindex];
		int fdin = open(in, O_RDWR, 0666);
		dup2(fdin,0);
		close(fdin);
		return mysys(buff);
	}
	else if(b != NULL)
	{
		char *out = argv[outindex];
		int fdout = open(out, O_CREAT|O_RDWR, 0666);
		dup2(fdout,1);
		close(fdout);
		return mysys(buff);
	}
	else
	{
		printf(&quot;debug1&quot;);
		int cmdStatus = choose_fun(buff);
		if(cmdStatus == 0)
			mysys(buff);
		else if(cmdStatus == 1)
		{
			char targetdir[256];
			sscanf(buff,&quot;cd %s&quot;,targetdir);
			chdir(targetdir);
		}
		else if(cmdStatus == 2)
			exit(0);
	}
}
int main()
{
	std_in = dup(0);
	std_out = dup(1);
	while(1)
	{
		loop();
	}
	return 0;
}

</div></code></pre>
<h4 id="232-sh2-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">2.3.2 sh2 实验结果</h4>
<h4 id="233-sh2-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">2.3.3 sh2 实验思路</h4>
<p>1.先验知识</p>
<p>(1) strchr()</p>
<p>函数原型：extern char *strchr(const char *s,char c)</p>
<p>函数功能：可以查找字符串 s 中首次出现字符 c 的位置</p>
<p>函数示例：</p>
<p>(2) dup2()</p>
<p>函数原型：int dup2(int oldfd, int newfd);</p>
<p>函数功能：dup2 可以用 newfd 参数指定新描述符的数值，如果 newfd 已经打开，则先将其关闭。如果 newfd 等于 oldfd，则 dup2 返回 newfd, 而不关闭它。dup2 函数返回的新文件描述符同样与参数 oldfd 共享同一文件表项。</p>
<p>函数示例：</p>
<pre class="hljs"><code><div>std_in = dup(0);
dup2(std_in,0);
</div></code></pre>
<p>2.实验思路
(1) 查看有无需要重定向的部分,定义a,b指针，调用strchr()函数扫描是否有'&lt;'以及'&gt;'字符。并且将指令按照空格解析出argv数组，并记录下'&lt;'与'&gt;'出现的位置，这样能够找到需要重定向的文件名了。扫描结果分别对应四个入如下。</p>
<table>
<thead>
<tr>
<th>扫描结果</th>
<th>解释</th>
<th>对应入口</th>
</tr>
</thead>
<tbody>
<tr>
<td>当a，b都不为空时</td>
<td>既有输出重定向，又有输入重定向</td>
<td>重定向输入与输出后判断调用mysys</td>
</tr>
<tr>
<td>当a为空，b不为空时</td>
<td>只有输出重定向，没有输入重定向</td>
<td>重定向输出后调用mysys</td>
</tr>
<tr>
<td>当b为空，a不为空时</td>
<td>没有输出重定向，只有输入重定向</td>
<td>重定向输入后调用mysys</td>
</tr>
<tr>
<td>当a,b都为空时</td>
<td>没有输入和输出重定向</td>
<td>直接调用mysys</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>    char *a = NULL;
	char *b = NULL;
	a = strchr(buff, '&lt;');
	b = strchr(buff, '&gt;');
    if(a != NULL &amp;&amp; b != NULL){}
	else if(a != NULL) {}
    else if(b != NULL) {}
    else {}
</div></code></pre>
<p>(2) 在重定向时用到了dup2这个命令，我们需要先正确打开对应的文件，然后调用dup2命令进行重定向。由于cd与exit命令无需用到重定向，所以在完成本条指令之后需要在mysys中将重定向后的再重定向回来。</p>
<pre class="hljs"><code><div>int mysys(char *command)
{   ...
    dup2(std_in,0);
	dup2(std_out,1);
    return status;
}

if(a != NULL &amp;&amp; b != NULL)
{
    char *in = argv[inindex];
    char *out = argv[outindex];
    int fdin,fdout;
    fdin = open(in,O_RDWR,0666);
    fdout = open(out,O_CREAT|O_RDWR,0666);
    if(fdin == -1)
    {
        printf(&quot;File %s open failed!\n&quot;,in);
        return -1;
    }
    if(fdout == -1)
    {
        printf(&quot;File %s open failed!\n&quot;,out);
        return -1;
    }
    dup2(fdin,0);
    dup2(fdout,1);
    close(fdin);
    close(fdout);
    return mysys(buff);
}

</div></code></pre>
<h3 id="24-sh3c-%E5%AE%9E%E7%8E%B0-shell-%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%A6%81%E6%B1%82%E5%9C%A8%E7%AC%AC-2-%E7%89%88%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E5%8A%9F%E8%83%BD">2.4 sh3.c: 实现 shell 程序，要求在第 2 版的基础上，添加如下功能</h3>
<ul>
<li>实现管道</li>
</ul>
<pre class="hljs"><code><div># 执行sh3
$ ./sh3

# 执行命令cat和wc，使用管道连接cat和wc
&gt; cat /etc/passwd | wc -l
</div></code></pre>
<ul>
<li>考虑如何实现管道和文件重定向</li>
</ul>
<pre class="hljs"><code><div>$ cat input.txt
3
2
1
3
2
1
$ cat &lt;input.txt | sort | uniq | cat &gt;output.txt
$ cat output.txt
1
2
3
</div></code></pre>
<h4 id="241-sh3-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">2.4.1 sh3 实验代码</h4>
<h4 id="242-sh3-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">2.4.2 sh3 实验结果</h4>
<h4 id="243-sh3-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">2.4.3 sh3 实验思路</h4>
<p>1.先验知识</p>
<p>(1) 管道</p>
<p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<p>1. 其本质是一个伪文件(实为内核缓冲区)</p>
<p>2. 由两个文件描述符引用，一个表示读端，一个表示写端。</p>
<p>3. 规定数据从管道的写端流入管道，从读端流出。</p>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>(2) 管道的局限性</p>
<p>1. 数据自己读不能自己写（其实可以，但没有意义）</p>
<p>2. 数据一旦被读走，便不在管道中存在，不可反复读取。</p>
<p>3. 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>4. 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<p>(3) 管道的使用</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>函数功能</th>
<th>函数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>pipe()</td>
<td>int pipe(int pipefd[2]);</td>
<td>函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</td>
<td>int fd[2]; pipe(fd);</td>
</tr>
<tr>
<td>write()</td>
<td>int write(int, const void *, unsigned int)</td>
<td>用于向管道中写数据</td>
<td>write(fds[1],&quot;hello&quot;,5);</td>
</tr>
<tr>
<td>read()</td>
<td>int read(int, void *, unsigned int)</td>
<td>用于读取管道中的数据</td>
<td>read(fds[0],buf,10);</td>
</tr>
</tbody>
</table>
<p>(4) 管道用于进程间通信</p>
<p>1. 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p>
<p>2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p>
<p>3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
<ol start="2">
<li>实验思路
(1) 主函数中仍然使用while循环来实现交互终端，函数loop用于解释执行命令，支持管道与重定向。由于管道是半双工的，定义了两个管道</li>
</ol>
<h1 id="3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E7%9B%AE">3. 多线程题目</h1>
<h3 id="31-pi1c-%E4%BD%BF%E7%94%A8-2-%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%A0%B9%E6%8D%AE%E8%8E%B1%E5%B8%83%E5%B0%BC%E5%85%B9%E7%BA%A7%E6%95%B0%E8%AE%A1%E7%AE%97-pi">3.1 pi1.c: 使用 2 个线程根据莱布尼兹级数计算 PI</h3>
<ul>
<li>莱布尼兹级数公式: 1 - 1/3 + 1/5 - 1/7 + 1/9 - ... = PI/4</li>
<li>主线程创建 1 个辅助线程</li>
<li>主线程计算级数的前半部分</li>
<li>辅助线程计算级数的后半部分</li>
<li>主线程等待辅助线程运行結束后,将前半部分和后半部分相加</li>
</ul>
<h4 id="311-pi1-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">3.1.1 pi1 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;

#define NUMBER 100000

double PI;
double worker_output;
double master_output;

void *worker(void *arg){
    int i;
    worker_output = 0;
    for(i = 1; i &lt;= NUMBER;i++){
        if(i % 2 == 0)
            worker_output -= 1/(2*(double)i - 1);
        else
            worker_output += 1/(2*(double)i - 1);
    }
}

void master(){
    int i;
    master_output = 0;
    for(i = NUMBER + 1;i &lt;= NUMBER*2;i++){
        if(i % 2 == 0)
            master_output -= 1 / (2 * (double)i - 1);
        else
            master_output += 1 / (2 * (double)i - 1);
    }
}

int main()
{
    pthread_t worker_tid;
    pthread_create(&amp;worker_tid, NULL, &amp;worker, NULL);
    master();
    pthread_join(worker_tid,NULL);
    PI = (worker_output + master_output) * 4;
    printf(&quot;PI:%lf\n&quot;,PI);
    return 0;
}

</div></code></pre>
<h4 id="312-pi1-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">3.1.2 pi1 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d127298c4ae7.png" alt="pi1.png"></p>
<h4 id="313-pi1-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">3.1.3 pi1 实验思路</h4>
<p>(1)使用两个线程计算 PI，主线程计算前半部分，辅助线程计算后半部分。将最后的计算结果相加后乘以 4 得到 PI 的估计值。采用 pthread_create 函数创建辅助线程，使用 pthread_join 函数等待辅助线程结束。</p>
<p>(2)worker 和 master 函数分别计算级数的后半段和前半段，迭代次数 NUMBER 越大，数字越精确。</p>
<h3 id="32-pi2c-%E4%BD%BF%E7%94%A8-n-%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%A0%B9%E6%8D%AE%E8%8E%B1%E5%B8%83%E5%B0%BC%E5%85%B9%E7%BA%A7%E6%95%B0%E8%AE%A1%E7%AE%97-pi">3.2 pi2.c: 使用 N 个线程根据莱布尼兹级数计算 PI</h3>
<ul>
<li>与上一题类似，但本题更加通用化，能适应 N 个核心，需要使用线程参数来实现</li>
<li>主线程创建 N 个辅助线程</li>
<li>每个辅助线程计算一部分任务，并将结果返回</li>
<li>主线程等待 N 个辅助线程运行结束，将所有辅助线程的结果累加</li>
</ul>
<h4 id="321-pi2-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">3.2.1 pi2 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;

#define NUMBER 100000
#define N 100

double PI;
struct param{
    int start;
    int end;
};

struct result{
    double worker_output;
};

void *worker(void *arg){
    int i;
    struct param *param;
    struct result *result;
    double worker_output = 0;
    param = (struct param *) arg;

    for(i = param-&gt;start; i &lt;= param-&gt;end;i++){
        if(i % 2 == 0)
            worker_output -= 1/(2*(double)i - 1);
        else
            worker_output += 1/(2*(double)i - 1);
    }
    result = malloc(sizeof(struct result));
    result-&gt;worker_output = worker_output;
	printf(&quot;worker %d = %.10lf\n&quot;,param-&gt;start / NUMBER, worker_output);
    return result;
}


int main()
{
    int i;
    pthread_t worker_tids[N];
    struct param params[N];
    PI = 0.0;

    for(i = 0; i &lt; N;i++){
        struct param *param;
        param = &amp;params[i];
        param-&gt;start =i * NUMBER + 1;
        param-&gt;end = (i+1) * NUMBER;
        pthread_create(&amp;worker_tids[i], NULL, worker, param);
    }

    for(i = 0;i &lt; N;i++){
        struct result *result;
        pthread_join(worker_tids[i],(void **)&amp;result);
        PI += result-&gt;worker_output;
        free(result);
    }
    PI = PI * 4;
    printf(&quot;PI:%.10lf\n&quot;,PI);
    return 0;
}
</div></code></pre>
<h4 id="322-pi2-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">3.2.2 pi2 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d127466c0a48.png" alt="pi2-2.png">
<img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d127466c4c6d.png" alt="pi2-1.png"></p>
<h4 id="323-pi2-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">3.2.3 pi2 实验思路</h4>
<p>(1) 主线程采用 for 循环产生 100 个线程来计算 PI。每个线程计算 1/100 的部分，计算起止点作为 pthread_create 函数的参数 param 传入辅助线程的线程入口函数。在 Worker 函数中，通过 param = (struct param *) arg 来接收传过来的 param 结构体。</p>
<p>(2) 主线程采用 for 循环，将每个辅助线程的计算结果利用 pthread_join 函数接受线程入口函数的返回值 result,然后获得每一个 worker 的 worker_output 在进行相加得到 PI 的值。</p>
<h3 id="33-sortc-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8E%92%E5%BA%8F">3.3 sort.c: 多线程排序</h3>
<ul>
<li>主线程创建一个辅助线程</li>
<li>主线程使用选择排序算法对数组的前半部分排序</li>
<li>辅助线程使用选择排序算法对数组的后半部分排序</li>
<li>主线程等待辅助线程运行結束后,使用归并排序算法归并数组的前半部分和后半部分</li>
</ul>
<h4 id="331-sort-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">3.3.1 sort 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;

#define MAX_ARRAY 100
#define MAX_NUM 10000

void *selectSort(void *argc){
    int *argv = (int *)argc;
    int i,j,min,record = -1,temp;
    for(i = 0;i &lt; MAX_ARRAY/2; ++i){
        min = argv[i];
        for(j = i;j &lt; MAX_ARRAY / 2;++j){
            if(argv[j] &lt; min){
                record = j;
                min = argv[j];
            }
        }
        temp = argv[i];
        argv[i] = argv[record];
        argv[record] = temp;
    }
    return NULL;
}

void Merge(int *arg1, int*arg2){
    int i = 0;
    int j = 0;
    int k = 0;
    for(j = MAX_ARRAY/2;i &lt; MAX_ARRAY/2 &amp;&amp; j &lt; MAX_ARRAY;++k){
        if(arg1[i] &lt; arg1[j])
            arg2[k] = arg1[i++];
        else
            arg2[k] = arg1[j++];
    }
    while(i &lt; MAX_ARRAY/2)
        arg2[k++] = arg1[i++];
    while(j &lt; MAX_ARRAY)
        arg2[k++] = arg1[j++];
    
}
void printArray(int *array){
    int i = 0;
    for(;i&lt;MAX_ARRAY;++i)
	{
        printf(&quot;%5d &quot;,array[i]);
		if((i+1) % 10 == 0 &amp;&amp; i!=1)
			printf(&quot;\n&quot;);
	}
	printf(&quot;\n&quot;);
}
int main(){
    int array[MAX_ARRAY],result[MAX_ARRAY];
    int i;
    for(i = 0;i &lt; MAX_ARRAY; ++i)
        array[i] = (rand() % MAX_NUM);

    printf(&quot;[UnSort ARRAY]!\n&quot;);
    printArray(array);
    pthread_t tid;
    int *arg = &amp;array[MAX_ARRAY/2];
    selectSort(array);
    pthread_create(&amp;tid, NULL, selectSort, (void *)arg);
    pthread_join(tid,NULL);

    printf(&quot;[SELECTSORT ARRAY]!\n&quot;);
    printArray(array);
    
    Merge(array,result);
    printf(&quot;[Sorted RESULT]!\n&quot;);
    printArray(result);
    return 0;
}

</div></code></pre>
<h4 id="332-sort-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">3.3.2 sort 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d1329b961faf.png" alt="sort1.png">
<img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d1329b960498.png" alt="sort2.png"></p>
<h4 id="333-sort-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">3.3.3 sort 实验思路</h4>
<p>(1)首先随机生成了100个数，将其打印。主线程调用selectSort函数进行前半部分的排序，采用pthread_create函数创建辅助线程，辅助线程使用选择排序算法对数组的后半部分排序。将辅助线程的排序任务起止点利用线程入口函数的参数传入。线程入口函数采用选择排序。使用pthread_join函数等待辅助线程结束。</p>
<pre class="hljs"><code><div>void *selectSort(void *argc){
    int *argv = (int *)argc;
    int i,j,min,record = -1,temp;
    for(i = 0;i &lt; MAX_ARRAY/2; ++i){
        min = argv[i];
        for(j = i;j &lt; MAX_ARRAY / 2;++j){
            if(argv[j] &lt; min){
                record = j;
                min = argv[j];
            }
        }
        temp = argv[i];
        argv[i] = argv[record];
        argv[record] = temp;
    }
    return NULL;
}

int array[MAX_ARRAY],result[MAX_ARRAY];
int i;
for(i = 0;i &lt; MAX_ARRAY; ++i)
    array[i] = (rand() % MAX_NUM);

printf(&quot;[UnSort ARRAY]!\n&quot;);
printArray(array);
pthread_t tid;
int *arg = &amp;array[MAX_ARRAY/2];
selectSort(array);
pthread_create(&amp;tid, NULL, selectSort, (void *)arg);
pthread_join(tid,NULL);

printf(&quot;[SELECTSORT ARRAY]!\n&quot;);
printArray(array);

</div></code></pre>
<p>(2)使用merge函数归并数组的前半部分和后半部分,直接在主线程里调用自定义的Merge函数即可将两个选择排序的结果归并排序完成。</p>
<pre class="hljs"><code><div>void Merge(int *arg1, int*arg2){
    int i = 0;
    int j = 0;
    int k = 0;
    for(j = MAX_ARRAY/2;i &lt; MAX_ARRAY/2 &amp;&amp; j &lt; MAX_ARRAY;++k){
        if(arg1[i] &lt; arg1[j])
            arg2[k] = arg1[i++];
        else
            arg2[k] = arg1[j++];
    }
    while(i &lt; MAX_ARRAY/2)
        arg2[k++] = arg1[i++];
    while(j &lt; MAX_ARRAY)
        arg2[k++] = arg1[j++];
    
}
Merge(array,result);
printf(&quot;[Sorted RESULT]!\n&quot;);
printArray(result);
</div></code></pre>
<h3 id="34-pc1c-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E8%AE%A1%E7%AE%97%E8%80%85%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">3.4 pc1.c: 使用条件变量解决生产者、计算者、消费者问题</h3>
<ul>
<li>系统中有 3 个线程：生产者、计算者、消费者</li>
<li>系统中有 2 个容量为 4 的缓冲区：buffer1、buffer2</li>
<li>生产者生产'a'、'b'、'c'、‘d'、'e'、'f'、'g'、'h'八*个字符，放入到 buffer1</li>
<li>计算者从 buffer1 取出字符，将小写字符转换为大写字符，放入到 buffer2</li>
<li>消费者从 buffer2 取出字符，将其打印到屏幕上</li>
</ul>
<h4 id="341-pc1-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">3.4.1 pc1 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;
#define CAPACITY 4

char buffer1[CAPACITY];
char buffer2[CAPACITY];
int in1,out1;
int in2,out2;

int buffer_is_empty(int index){
    if(index == 1)
        return in1 == out1;
    if(index == 2)
        return in2 == out2;
    else
        printf(&quot;Don`t exist this buffer!,Empty&quot;);
}

int buffer_is_full(int index){
    if(index == 1)
        return (in1 + 1) % CAPACITY == out1;
    if(index == 2)
        return (in2 + 1) % CAPACITY == out2;
    else
        printf(&quot;Don`t exist this buffer!,Full&quot;);
}
char get_item(int index){
    char item;
    if(index == 1){
        item = buffer1[out1];
        out1 = (out1 + 1) % CAPACITY;
    }
    if(index == 2){
        item = buffer2[out2];
        out2 = (out2 + 1) % CAPACITY;
    }
    //else
    //  printf(&quot;Don`t exist this buffer!,Get%d\n&quot;,index);
    return item;
}

void put_item(char item, int index){
    if(index == 1){
        buffer1[in1] = item;
        in1 = (in1 + 1) % CAPACITY;
    }
    if(index == 2){
        buffer2[in2] = item;
        in2 = (in2 + 1) % CAPACITY;
    }
    //else
    //    printf(&quot;Don`t exist this buffer!Put%c  %d\n&quot;,item,index);
}

pthread_mutex_t mutex1,mutex2;
pthread_cond_t wait_empty_buffer1;
pthread_cond_t wait_full_buffer1;
pthread_cond_t wait_empty_buffer2;
pthread_cond_t wait_full_buffer2;


volatile int global = 0;

#define ITEM_COUNT 8

void *produce(void *arg){
    int i;
    char item;

    for(i = 0;i &lt; ITEM_COUNT;i++){
        pthread_mutex_lock(&amp;mutex1);
        while(buffer_is_full(1))
            pthread_cond_wait(&amp;wait_empty_buffer1, &amp;mutex1);
        item = 'a' + i;
        put_item(item,1);
        printf(&quot;produce item:%c\n&quot;,item);

        pthread_cond_signal(&amp;wait_full_buffer1);
        pthread_mutex_unlock(&amp;mutex1);
    }
    return NULL;
}
void *compute(void *arg){
    int i;
    char item;
    for(i = 0;i &lt; ITEM_COUNT;i++){
        pthread_mutex_lock(&amp;mutex1);
        while(buffer_is_empty(1))
            pthread_cond_wait(&amp;wait_full_buffer1, &amp;mutex1);
        item = get_item(1);
        //printf(&quot;    compute get item:%c\n&quot;,item);
        pthread_cond_signal(&amp;wait_empty_buffer1);
        pthread_mutex_unlock(&amp;mutex1);

        item -= 32;

		pthread_mutex_lock(&amp;mutex2);
        while(buffer_is_full(2))
            pthread_cond_wait(&amp;wait_empty_buffer2, &amp;mutex2);
        put_item(item,2);
        printf(&quot;    compute put item:%c\n&quot;, item);
        pthread_cond_signal(&amp;wait_full_buffer2);
        pthread_mutex_unlock(&amp;mutex2);
    }
    return NULL;
}

void *consume(void *arg){
    int i;
    char item;
    for(i = 0;i &lt; ITEM_COUNT;i++){
        pthread_mutex_lock(&amp;mutex2);
        while(buffer_is_empty(2))
            pthread_cond_wait(&amp;wait_full_buffer2, &amp;mutex2);
        item = get_item(2);
        printf(&quot;            comsume item:%c\n&quot;, item);

        pthread_cond_signal(&amp;wait_empty_buffer2);
        pthread_mutex_unlock(&amp;mutex2);
    }
    return NULL;
}

int main(){
    int i;
    in1 = 0;
    in2 = 0;
    out1 = 0;
    out2 = 0;
    pthread_t tids[3];
	pthread_create(&amp;tids[0],NULL,produce,NULL);
    pthread_create(&amp;tids[1],NULL,compute,NULL);
    pthread_create(&amp;tids[2],NULL,consume,NULL);

    pthread_mutex_init(&amp;mutex1, NULL);
	pthread_mutex_init(&amp;mutex2, NULL);
    pthread_cond_init(&amp;wait_empty_buffer1, NULL);
    pthread_cond_init(&amp;wait_full_buffer1, NULL);
    pthread_cond_init(&amp;wait_empty_buffer2, NULL);
    pthread_cond_init(&amp;wait_full_buffer2, NULL);

    for(i = 0;i &lt; 3;i++)
        pthread_join(tids[i],NULL);
    pthread_mutex_destroy(&amp;mutex1);
	pthread_mutex_destroy(&amp;mutex2);


    return 0;
}
</div></code></pre>
<h4 id="342-pc2-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">3.4.2 pc2 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d12dae722aa3.png" alt="pc1.png"></p>
<h4 id="343-pc2-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">3.4.3 pc2 实验思路</h4>
<p>1.先验知识</p>
<p>(1) pthread_mutex_t 与 pthread_cond_t</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>类型功能</th>
<th>声明原型</th>
<th>声明示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_mutex_t</td>
<td>声明一个互斥锁(用于线程互斥)</td>
<td>typedef void *pthread_mutex_t</td>
<td>pthread_mutex_t mutex1,mutex2;</td>
</tr>
<tr>
<td>pthread_cond_t</td>
<td>声明一个条件变量(用于线程同步)</td>
<td>typedef void *pthread_mutex_t</td>
<td>pthread_cond_t wait_empty_buffer1;</td>
</tr>
</tbody>
</table>
<p>(2) pthread_mutex_lock() 和 pthread_mutex_unlock()</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数功能</th>
<th>函数原型</th>
<th>函数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_mutex_lock()</td>
<td>对互斥锁加锁</td>
<td>int pthread_mutex_lock(pthread_mutex_t *m)</td>
<td>pthread_mutex_lock(&amp;mutex1);</td>
</tr>
<tr>
<td>pthread_mutex_unlock()</td>
<td>对互斥锁解锁</td>
<td>int pthread_mutex_unlock(pthread_mutex_t *m)</td>
<td>pthread_mutex_unlock(&amp;mutex1);</td>
</tr>
</tbody>
</table>
<p>(3) pthread_cond_wait() 和 pthread_cond_signal()</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数功能</th>
<th>函数原型</th>
<th>函数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_cond_wait()</td>
<td>无条件等待</td>
<td>int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *external_mutex)</td>
<td>pthread_cond_wait(&amp;wait_empty_buffer1, &amp;mutex1);</td>
</tr>
<tr>
<td>pthread_cond_signal()</td>
<td>激活等待的线程</td>
<td>int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *external_mutex)</td>
<td>pthread_cond_signal(&amp;wait_full_buffer1);</td>
</tr>
</tbody>
</table>
<p>(4) pthread_mutex_init()、pthread_mutex_destroy() 和 pthread_cond_init()</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数功能</th>
<th>函数原型</th>
<th>函数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_mutex_init()</td>
<td>互斥锁的初始化</td>
<td>int pthread_mutex_init(pthread_mutex_t _mutex, const pthread_mutexattr_t _ attr)</td>
<td>pthread_mutex_init(&amp;mutex1, NULL);</td>
</tr>
<tr>
<td>pthread_mutex_destory()</td>
<td>互斥锁的释放</td>
<td>int pthread_mutex_destroy(pthread_mutex_t *m)</td>
<td>pthread_mutex_destroy(&amp;mutex1);</td>
</tr>
<tr>
<td>pthread_cond_init()</td>
<td>条件变量的初始化</td>
<td>int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *a)</td>
<td>thread_cond_init(&amp;wait_empty_buffer1, NULL);</td>
</tr>
</tbody>
</table>
<p>(5) pthread_create() 和 pthread_join()</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数功能</th>
<th>函数原型</th>
<th>函数示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_create()</td>
<td>线程的创建</td>
<td>int pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(*func)(void *), void *arg)</td>
<td>pthread_create(&amp;tids,NULL,produce,NULL);</td>
</tr>
<tr>
<td>pthread_join()</td>
<td>用于等待一个线程的结束,线程间同步的操作</td>
<td>int pthread_join(pthread_t t, void **res)</td>
<td>pthread_join(tids,NULL);</td>
</tr>
</tbody>
</table>
<p>2.实验思路</p>
<p>(1) 定义两个容量为 4 的 buffer：buffer1 与 buffer2。计算者从 buffer1 取出字符，将小写字符转换为大写字符，放入到 buffer2。消费者从 buffer2 取出字符，将其打印到屏幕上。定义互斥信号量用于进程间互斥，定义条件变量用于进程间同步</p>
<pre class="hljs"><code><div>#define CAPACITY 4                  //缓冲区的大小
#define ITEM_COUNT 8                //字符的数量
char buffer1[CAPACITY];
char buffer2[CAPACITY];
int in1,out1;                       //定义当前buffer1的读指针和写指针
int in2,out2;                       //定义当前buffer2的读指针和写指针
pthread_mutex_t mutex1,mutex2;      //定义互斥信号量
pthread_cond_t wait_empty_buffer1;
pthread_cond_t wait_full_buffer1;   //定义条件变量用于produce与compute之间的同步
pthread_cond_t wait_empty_buffer2;
pthread_cond_t wait_full_buffer2;   //定义条件变量用于compute与consume之间的同步
</div></code></pre>
<p>(2) produce 程序作为 buffer1 的生产者，在操作之前给 buffer1 加锁并将数据存入。</p>
<pre class="hljs"><code><div>void *produce(void *arg){
    int i;
    char item;

    for(i = 0;i &lt; ITEM_COUNT;i++){
        pthread_mutex_lock(&amp;mutex);                         //对互斥锁进行加锁
        while(buffer_is_full(1))
            pthread_cond_wait(&amp;wait_empty_buffer1, &amp;mutex); //P操作：若buffer1满了就等待其为空
        item = 'a' + i;
        put_item(item,1);
        printf(&quot;produce item:%c\n&quot;,item);

        pthread_cond_signal(&amp;wait_full_buffer1);            //V操作：将buffer1的数据缓冲区数目(wait_full_buffer1) + 1
        pthread_mutex_unlock(&amp;mutex);                       //释放信号量
    }
    return NULL;
}
</div></code></pre>
<p>(3) compute 程序先作为 buffer1 的消费者，给 buffer1 加锁并取数；计算者将小写字母变成大写字母；计最后再作为 buffer2 的生产者，给 buffer2 加锁并存数。</p>
<pre class="hljs"><code><div>void *compute(void *arg){
    int i;
    char item;

    for(i = 0;i &lt; ITEM_COUNT;i++){
        pthread_mutex_lock(&amp;mutex1);                        //对信号量1加锁
        while(buffer_is_empty(1))
            pthread_cond_wait(&amp;wait_full_buffer1, &amp;mutex1); //P操作：若buffer1为空则持续等待
        item = get_item(1);
        //printf(&quot;    compute get item:%c\n&quot;,item);
        pthread_cond_signal(&amp;wait_empty_buffer1);           //V操作：将buffer1的数据缓冲区数目(wait_empty_buffer1)-1
        pthread_mutex_unlock(&amp;mutex1);                      //释放信号量1

        item -= 32;

        pthread_mutex_lock(&amp;mutex2);                        //对信号量2加锁
        while(buffer_is_full(2))
            pthread_cond_wait(&amp;wait_empty_buffer2, &amp;mutex2);//P操作：若buffer2满了则持续等待
        put_item(item,2);
        printf(&quot;    compute put item:%c\n&quot;, item);
        pthread_cond_signal(&amp;wait_full_buffer2);            //V操作：将buffer2的数据缓冲区数目(wait_full_buffer2)+1
        pthread_mutex_unlock(&amp;mutex2);                      //释放信号量2
    }
    return NULL;
}
</div></code></pre>
<p>(4)消费者作为 buffer2 的消费者，给 buffer2 加锁并取数字。</p>
<pre class="hljs"><code><div>void *consume(void *arg){
    int i;
    char item;
    for(i = 0;i &lt; ITEM_COUNT;i++){
        pthread_mutex_lock(&amp;mutex2);                        //对信号量2加锁
        while(buffer_is_empty(2))
            pthread_cond_wait(&amp;wait_full_buffer2, &amp;mutex2); //P操作：若buffer2为空则持续等待
        item = get_item(2);
        printf(&quot;            comsume item:%c\n&quot;, item);
        pthread_cond_signal(&amp;wait_empty_buffer2);           //V操作：将buffer2的数据缓冲区数目(wait_empty_buffer2)-1
        pthread_mutex_unlock(&amp;mutex2);                      //释放信号量2
    }
    return NULL;
}
</div></code></pre>
<p>(5)在主函数中创建三个线程分别用于承担生产者，计算者与消费者。对线程进行初始化，并且定义两个锁用于线程间互斥，再定义四个信号量用于线程间同步，再将三个进程都调用 pthread_join()函数等待线程结束，最终对互斥锁进行注销。</p>
<pre class="hljs"><code><div>int main(){
    int i;
    in1 = 0;
    in2 = 0;
    out1 = 0;
    out2 = 0;
    pthread_t tids[3];
	pthread_create(&amp;tids[0],NULL,produce,NULL);
    pthread_create(&amp;tids[1],NULL,compute,NULL);
    pthread_create(&amp;tids[2],NULL,consume,NULL);

    pthread_mutex_init(&amp;mutex1, NULL);
	pthread_mutex_init(&amp;mutex2, NULL);
    pthread_cond_init(&amp;wait_empty_buffer1, NULL);
    pthread_cond_init(&amp;wait_full_buffer1, NULL);
    pthread_cond_init(&amp;wait_empty_buffer2, NULL);
    pthread_cond_init(&amp;wait_full_buffer2, NULL);

    for(i = 0;i &lt; 3;i++)
        pthread_join(tids[i],NULL);
    pthread_mutex_destroy(&amp;mutex1);
	pthread_mutex_destroy(&amp;mutex2);

    return 0;
}
</div></code></pre>
<h3 id="35-pc2c-%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E8%AE%A1%E7%AE%97%E8%80%85%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">3.5 pc2.c: 使用信号量解决生产者、计算者、消费者问题</h3>
<ul>
<li>功能和前面的实验相同，使用信号量解决</li>
</ul>
<h4 id="351-pc2-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">3.5.1 pc2 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;
#define CAPACITY 4

char buffer1[CAPACITY];
char buffer2[CAPACITY];
int in1,out1;
int in2,out2;

int buffer_is_empty(int index){
    if(index == 1)
        return in1 == out1;
    if(index == 2)
        return in2 == out2;
    else
        printf(&quot;Don`t exist this buffer!,Empty&quot;);
}

int buffer_is_full(int index){
    if(index == 1)
        return (in1 + 1) % CAPACITY == out1;
    if(index == 2)
        return (in2 + 1) % CAPACITY == out2;
    else
        printf(&quot;Don`t exist this buffer!,Full&quot;);
}
char get_item(int index){
    char item;
    if(index == 1){
        item = buffer1[out1];
        out1 = (out1 + 1) % CAPACITY;
    }
    if(index == 2){
        item = buffer2[out2];
        out2 = (out2 + 1) % CAPACITY;
    }
    //else
    //  printf(&quot;Don`t exist this buffer!,Get%d\n&quot;,index);
    return item;
}

void put_item(char item, int index){
    if(index == 1){
        buffer1[in1] = item;
        in1 = (in1 + 1) % CAPACITY;
    }
    if(index == 2){
        buffer2[in2] = item;
        in2 = (in2 + 1) % CAPACITY;
    }
    //else
    //    printf(&quot;Don`t exist this buffer!Put%c  %d\n&quot;,item,index);
}

typedef struct{
    int value;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
}sema_t;

void sema_init(sema_t *sema, int value){
    sema-&gt;value = value;
    pthread_mutex_init(&amp;sema-&gt;mutex, NULL);
    pthread_cond_init(&amp;sema-&gt;cond, NULL);
}

void sema_wait(sema_t *sema){
    pthread_mutex_lock(&amp;sema-&gt;mutex);
    while(sema-&gt;value &lt;= 0)
        pthread_cond_wait(&amp;sema-&gt;cond, &amp;sema-&gt;mutex);
    sema-&gt;value--;
    pthread_mutex_unlock(&amp;sema-&gt;mutex);
}

void sema_signal(sema_t *sema){
    pthread_mutex_lock(&amp;sema-&gt;mutex);
    ++sema-&gt;value;
    pthread_cond_signal(&amp;sema-&gt;cond);
    pthread_mutex_unlock(&amp;sema-&gt;mutex);
}

sema_t mutex_sema1,mutex_sema2;
sema_t empty_buffer_sema1;
sema_t full_buffer_sema1;
sema_t empty_buffer_sema2;
sema_t full_buffer_sema2;

volatile int global = 0;

#define ITEM_COUNT 8

void *produce(void *arg){
    int i;
    char item;

    for(i = 0;i &lt; ITEM_COUNT;i++){
        sema_wait(&amp;empty_buffer_sema1);
        sema_wait(&amp;mutex_sema1);

        item = 'a' + i;
        put_item(item,1);
        printf(&quot;produce item:%c\n&quot;,item);

        sema_signal(&amp;mutex_sema1);
        sema_signal(&amp;full_buffer_sema1);
    }
    return NULL;
}
void *compute(void *arg){
    int i;
    char item;
    for(i = 0;i &lt; ITEM_COUNT;i++){
        sema_wait(&amp;full_buffer_sema1);
        sema_wait(&amp;mutex_sema1);

        item = get_item(1);
        // printf(&quot;    compute get item:%c\n&quot;,item);

        sema_signal(&amp;mutex_sema1);
        sema_signal(&amp;empty_buffer_sema1);

        item -= 32;

        sema_wait(&amp;empty_buffer_sema2);
        sema_wait(&amp;mutex_sema2);

        put_item(item,2);
        printf(&quot;    compute put item:%c\n&quot;, item);

        sema_signal(&amp;mutex_sema2);
        sema_signal(&amp;full_buffer_sema2);
    }
    return NULL;
}

void *consume(void *arg){
    int i;
    char item;
    for(i = 0;i &lt; ITEM_COUNT;i++){

        sema_wait(&amp;full_buffer_sema2);
        sema_wait(&amp;mutex_sema2);

        item = get_item(2);
        printf(&quot;            comsume item:%c\n&quot;, item);

        sema_signal(&amp;mutex_sema2);
        sema_signal(&amp;empty_buffer_sema2);
    }
    return NULL;
}

int main(){
    int i;
    in1 = 0;
    in2 = 0;
    out1 = 0;
    out2 = 0;
    pthread_t tids[3];

    sema_init(&amp;mutex_sema1, 1);
	sema_init(&amp;mutex_sema2, 1);
    sema_init(&amp;empty_buffer_sema1,CAPACITY - 1);
    sema_init(&amp;full_buffer_sema1,0);
    sema_init(&amp;empty_buffer_sema2,CAPACITY - 1);
    sema_init(&amp;full_buffer_sema1,0);


	pthread_create(&amp;tids[0],NULL,produce,NULL);
    pthread_create(&amp;tids[1],NULL,compute,NULL);
    pthread_create(&amp;tids[2],NULL,consume,NULL);

    for(i = 0;i &lt; 3;i++)
        pthread_join(tids[i],NULL);


    return 0;
}
</div></code></pre>
<h4 id="352-pc2-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">3.5.2 pc2 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d12e7f6a73a3.png" alt="pc2.png"></p>
<h4 id="353-pc2-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">3.5.3 pc2 实验思路</h4>
<p>(1) 信号量的实现</p>
<p>此题与上题思路相同，区别在于实现的时候利用信号量。信号量的定义、初始化、wait 和 signal 定义如下，初始化时可以送入信号量的初始个数，wait 一次减少一次信号量个数，signal 一次则增加一次信号量个数。</p>
<pre class="hljs"><code><div>typedef struct{
    int value;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
}sema_t;

void sema_init(sema_t *sema, int value){
    sema-&gt;value = value;
    pthread_mutex_init(&amp;sema-&gt;mutex, NULL);
    pthread_cond_init(&amp;sema-&gt;cond, NULL);
}

void sema_wait(sema_t *sema){
    pthread_mutex_lock(&amp;sema-&gt;mutex);
    while(sema-&gt;value &lt;= 0)
        pthread_cond_wait(&amp;sema-&gt;cond, &amp;sema-&gt;mutex);
    sema-&gt;value--;
    pthread_mutex_unlock(&amp;sema-&gt;mutex);
}

void sema_signal(sema_t *sema){
    pthread_mutex_lock(&amp;sema-&gt;mutex);
    ++sema-&gt;value;
    pthread_cond_signal(&amp;sema-&gt;cond);
    pthread_mutex_unlock(&amp;sema-&gt;mutex);
}
</div></code></pre>
<p>(2)定义信号量并使用</p>
<p>定义两个信号量 mutex_sema1,mutex_sema2，分别对(生产者-计算者)与(计算者-消费者)进行线程间互斥。此外也定义了四个信号量
对共享变量 buffer1,buffer2 进行线程间同步。</p>
<p>在生产者、计算者、消费者的函数中，先进行 P 操作等待互斥信号量(上锁)，再 P 操作获取同步信号量，对 buffer 中的数据进行操作后，V 操作释放互斥信号量及同步信号量(解锁)。这里值得注意的是，需要 P 操作需要先获取同步信号量再对互斥信号量进行上锁，不然可能造饥饿的现象。</p>
<pre class="hljs"><code><div>sema_t mutex_sema1,mutex_sema2;
sema_t empty_buffer_sema1;
sema_t full_buffer_sema1;
sema_t empty_buffer_sema2;
sema_t full_buffer_sema2;
void *produce(void *arg){
    int i;
    char item;

    for(i = 0;i &lt; ITEM_COUNT;i++){
        sema_wait(&amp;empty_buffer_sema1);
        sema_wait(&amp;mutex_sema1);

        item = 'a' + i;
        put_item(item,1);
        printf(&quot;produce item:%c\n&quot;,item);

        sema_signal(&amp;mutex_sema1);
        sema_signal(&amp;full_buffer_sema1);
    }
    return NULL;
}
void *compute(void *arg){
    int i;
    char item;
    for(i = 0;i &lt; ITEM_COUNT;i++){
        sema_wait(&amp;full_buffer_sema1);
        sema_wait(&amp;mutex_sema1);

        item = get_item(1);
        // printf(&quot;    compute get item:%c\n&quot;,item);

        sema_signal(&amp;mutex_sema1);
        sema_signal(&amp;empty_buffer_sema1);

        item -= 32;

        sema_wait(&amp;empty_buffer_sema2);
        sema_wait(&amp;mutex_sema2);

        put_item(item,2);
        printf(&quot;    compute put item:%c\n&quot;, item);

        sema_signal(&amp;mutex_sema2);
        sema_signal(&amp;full_buffer_sema2);
    }
    return NULL;
}

void *consume(void *arg){
    int i;
    char item;
    for(i = 0;i &lt; ITEM_COUNT;i++){

        sema_wait(&amp;full_buffer_sema2);
        sema_wait(&amp;mutex_sema2);

        item = get_item(2);
        printf(&quot;            comsume item:%c\n&quot;, item);

        sema_signal(&amp;mutex_sema2);
        sema_signal(&amp;empty_buffer_sema2);
    }
    return NULL;
}
</div></code></pre>
<p>(3) main 函数中开启三个线程分别对应生产者、计算者、消费者，再对两个互斥信号量以及四个同步信号量进行初始化，调用 pthread_join 函数等待三个进程的结束即可。</p>
<pre class="hljs"><code><div>int main(){
    int i;
    in1 = 0;
    in2 = 0;
    out1 = 0;
    out2 = 0;
    pthread_t tids[3];

    sema_init(&amp;mutex_sema1, 1);
	sema_init(&amp;mutex_sema2, 1);
    sema_init(&amp;empty_buffer_sema1,CAPACITY - 1);
    sema_init(&amp;full_buffer_sema1,0);
    sema_init(&amp;empty_buffer_sema2,CAPACITY - 1);
    sema_init(&amp;full_buffer_sema1,0);


	pthread_create(&amp;tids[0],NULL,produce,NULL);
    pthread_create(&amp;tids[1],NULL,compute,NULL);
    pthread_create(&amp;tids[2],NULL,consume,NULL);

    for(i = 0;i &lt; 3;i++)
        pthread_join(tids[i],NULL);


    return 0;
}

</div></code></pre>
<h3 id="36-ringc-%E5%88%9B%E5%BB%BA-n-%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%9E%84%E6%88%90%E4%B8%80%E4%B8%AA%E7%8E%AF">3.6 ring.c: 创建 N 个线程，它们构成一个环</h3>
<ul>
<li>创建 N 个线程：T1、T2、T3、… TN</li>
<li>T1 向 T2 发送整数 1</li>
<li>T2 收到后将整数加 1</li>
<li>T2 向 T3 发送整数 2</li>
<li>T3 收到后将整数加 1</li>
<li>T3 向 T4 发送整数 3</li>
<li>…</li>
<li>TN 收到后将整数加 1</li>
<li>TN 向 T1 发送整数 N</li>
</ul>
<h4 id="361-ring-%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81">3.6.1 ring 实验代码</h4>
<pre class="hljs"><code><div>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;
#define N 100
int buffer = 0;

void *add(void *arg){
    int *num = (int *)arg;
    num[0]++;
    int *result = num;
    return (void *)result;
}

void init(int a[N][2]){
    int i;
    for(i = 0;i &lt; N;i++){
        a[i][0] = 0;
        a[i][1] = i;
    }
}


int main(){
    int i = 0;
    int array[N][2];
    init(array);
    int *result;

    pthread_t tids[N];
    pthread_create(&amp;tids[0],NULL,add,(void *)array[0]);
    pthread_join(tids[0], (void *)&amp;result);

    while(i &lt; N){
        printf(&quot;from T[%d]&quot;, i+1);
        i = (i+1) % N;
        printf(&quot;to T[%d] send %d\n&quot;,i+1,result[0]);
        pthread_create(&amp;tids[i],NULL,add,result);
        pthread_join(tids[i], (void *)&amp;result);
		if(i == 0)
			break;
       // sleep(1);
    }

    return 0;
}

</div></code></pre>
<h4 id="362-ring-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">3.6.2 ring 实验结果</h4>
<p><img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d132291b95e4.png" alt="ring-1.png">
<img src="https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/2019/06/26/5d1322298eb0f.png" alt="ring-2.png"></p>
<h4 id="363-ring-%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF">3.6.3 ring 实验思路</h4>
<p>(1) 创建 N 个容量为 2 的缓冲区 array[N][2],初始化每个缓冲区的第一个数字都为 0，第二个数字为当前缓冲区的编号。接着定义了一个数字数组 result.创建 N 个线程，对第一个线程进行初始化，该进程运行 add 函数，然后将 array[0]作为参数传入 add 函数中。并调用 pthread_join()函数等待线程结束。</p>
<pre class="hljs"><code><div>void *add(void *arg){
    int *num = (int *)arg;
    num[0]++;
    int *result = num;
    return (void *)result;
}

void init(int a[N][2]){
    int i;
    for(i = 0;i &lt; N;i++){
        a[i][0] = 0;
        a[i][1] = i;
    }
}

int i = 0;
int array[N][2];
init(array);
int *result;

pthread_t tids[N];
pthreaad_create(&amp;tids[0],NULL,add,(void *)array[0]);
pthread_join(tids[0], (void *)&amp;result);

</div></code></pre>
<p>(2) 在循环中，首先打印发送方的信息，然后 i 循环加 1，然后打印接收方的信息并创建线程，将收到的数作为参数传入线程中执行 add 函数，并调用 pthread_join()函数等待线程结束。当 i 循环加 1 到 0 到 i 为 0 时(又返回第一个缓冲区)时结束。</p>
<pre class="hljs"><code><div>while(i &lt; N){
    printf(&quot;from T[%d]&quot;, i+1);
    i = (i+1) % N;
    printf(&quot;to T[%d] send %d\n&quot;, i+1, result[0]);
    pthread_create(&amp;tids[i],NULL,add,result);
    pthread_join(tids[i], (void *)&amp;result);
    if(i == 0)
        break;
    // sleep(1);
}
</div></code></pre>

</body>
</html>
